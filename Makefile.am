ACLOCAL_AMFLAGS = -I m4

# Remove the tedium of keeping track whether an automake variable
# previously was assigned to, and whether = or += _must_ be used.
# Start empty, and always append.
bin_PROGRAMS =
noinst_LTLIBRARIES =
lib_LTLIBRARIES =

# Create a library which contains the drivers' code.
DRIVERS_LIBRARY = src/libdrivers.la
noinst_LTLIBRARIES += $(DRIVERS_LIBRARY)
src_libdrivers_la_SOURCES = src/driver_1.c src/driver_2.c src/drivers.c src/drivers.h

# Create an object file(!) which contains all drivers' code _and_
# their registration data, including a list(!) of all drivers which
# were built into the library.
#
# Then create a shared library with all the library code (comms and
# other library code, drivers, and their registration data and logic
# to iterate the list of drivers).
#
# There are several implementation details to remain aware about
# this approach:
# - libtool supports partial linking when the target is .o or .lo
# - official automake syntax (in combination with libtool) lacks
#   support to create .o or .lo files from user provided(!) specs
# - libtool keeps ignoring linker scripts which are passed on the
#   command line where archives and objects are specified, but it's
#   essential to _add_ this local linker script and not _replace_
#   the linker's default script for the target
# - libtool keeps rearranging the command line words, breaking the
#   linker's command line (whole archive for .a to .o conversion)
#
# That's why several unexpected choices had to be made here:
# - create the .o file by means of a direct ld(1) invocation
# - create the .lo by custom make(1) logic to make libtool happy
# - pass the linker script with -Wc so that libtool will pass it
#   on, yet not replace the linker's script but augment it
DRIVERS_LDSCRIPT = $(srcdir)/src/drivers.ld

# TODO Extract the .a from the .la somehow? Unfortunately libtool does
# not have -print-file-name as gcc(1) does.
# TODO Is the name platform dependent, need we use $(libext) variables?
# grep(1) for '\.a' in the .la file? Still need to add the .libs/ dir.
# Lots of magic involved, but we also manually create the .lo file since
# automake won't let us create .lo targets from official .am syntax. :(
DRIVERS_A_FILENAME = src/.libs/libdrivers.a

DRVLIST_OBJECT = src/drvlist.o
DRVLIST_LTOBJECT = src/drvlist.lo

$(DRVLIST_OBJECT): $(DRIVERS_LIBRARY) $(DRIVERS_LDSCRIPT)
	$(AM_V_CCLD)$(LD) -r -o $@ --whole-archive $(DRIVERS_A_FILENAME) --no-whole-archive $(DRIVERS_LDSCRIPT)

$(DRVLIST_LTOBJECT): $(DRVLIST_OBJECT)
	$(AM_V_GEN)echo "# Generated by libtool" > $@
	$(AM_V_at)echo "# AUTO GENERATED, DO NOT EDIT" >> $@
	$(AM_V_at)echo "pic_object='`basename $^`'" >> $@
	$(AM_V_at)echo "non_pic_object='`basename $^`'" >> $@

COMBO_LIBRARY = src/libcombo.la
lib_LTLIBRARIES += $(COMBO_LIBRARY)
src_libcombo_la_SOURCES = src/comm.c src/comm.h
src_libcombo_la_LIBADD = $(DRVLIST_LTOBJECT)
src_libcombo_la_LDFLAGS = -version-info 1:2:0
src_libcombo_la_LDFLAGS += --emit-relocs -fno-lto -Wc,$(DRIVERS_LDSCRIPT)
EXTRA_src_libcombo_la_DEPENDENCIES = $(DRIVERS_LDSCRIPT)

# Create an application which uses the combined library.
bin_PROGRAMS += app_combo
app_combo_SOURCES = src/app_main.c
app_combo_LDADD = $(COMBO_LIBRARY)
